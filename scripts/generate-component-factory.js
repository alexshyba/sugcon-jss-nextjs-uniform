const fs = require('fs-extra');
const path = require('path');

/*
  COMPONENT FACTORY GENERATION
  Generates the /src/componentFactory.js file which maps React components
  to JSS components.

  The component factory is a mapping between a string name and a React component instance.
  When the Sitecore Layout service returns a layout definition, it returns named components.
  This mapping is used to construct the component hierarchy for the layout.
*/

/* eslint-disable no-console */

// const componentLibraryModuleName = '@altola/jss-components';
// const componentLibraryModuleBasePath = '@altola/jss-components/dist';
// const componentLibraryModuleResolvedBasePath = path.resolve(
//   path.join('node_modules', componentLibraryModuleBasePath)
// );

const componentLibraryModuleBasePath ="../";
const componentLibraryModuleResolvedBasePath = "src"
const componentRootPath = 'src/components';
const componentLibraryExportsPath = path.join(componentRootPath, 'index.js');
const componentFactoryPath = path.resolve('src/temp/componentFactory.tsx');

// The `dynamicImports` array should contain component names that will be used
// to map component instances to component names in the component factory.
const allowedDynamicImports = ['MapBlock', 'VideoBlock', 'Speakers', 'CtaSection', 'TeaserSection', 'PricingSection', 'CtaBlock'];
const excludeComponents = [];

const isWatch = process.argv.some((arg) => arg === '--watch');

if (isWatch) {
  // TODO:
  // watchComponentFactory();
  writeComponentFactory();
} else {
  writeComponentFactory();
}

function watchComponentFactory() {
  console.log(`Watching for changes to component factory sources in ${componentRootPath}...`);

  chokidar
    .watch(componentRootPath, { ignoreInitial: true, awaitWriteFinish: true })
    .on('add', writeComponentFactory)
    .on('unlink', writeComponentFactory);
}

function writeComponentFactory() {
  const componentFactory = generateComponentFactory();

  console.log(`Writing component factory to ${componentFactoryPath}`);

  const fileContents = fs.readFileSync(componentFactoryPath).toString();
  const markerRegex = new RegExp(/\/\/ <auto-generated-imports>.*\/\/ <\/auto-generated-imports>/, 'gmis');
  if (!fileContents || fileContents.search(markerRegex) === -1) {
    console.warn(
      `No start marker was found in the following file: '${componentFactoryPath}'. Be sure the file contains \`// <auto-generated-imports>\` and \`// </auto-generate-imports>\` comments to denote where auto-generated import statements and component registrations should be placed.`
    );
    return;
  }

  const newFileContents = fileContents.replace(
    markerRegex,
    `// <auto-generated-imports>\n${componentFactory}\n// </auto-generated-imports>`
  );

  fs.writeFileSync(componentFactoryPath, newFileContents, { encoding: 'utf8' });
}

function generateComponentFactory() {
  const componentRootPath = path.join(componentLibraryModuleResolvedBasePath, 'components');

  const imports = [];
  const registrations = [];

  const libraryExportsContents = fs.readFileSync(componentLibraryExportsPath);

  recursiveFindComponents(componentRootPath, {
    registrations,
    imports,
    libraryExportsContents,
    allowedDynamicImports,
  });

  return `
${
  imports.length > 0
    ? `
import {
${imports.join(',\n')}
} from '../components';`
    : ''
}

const components = new Map();
${registrations.join('\n')}
`;
}

function recursiveFindComponents(
  componentFolderFullPath,
  { registrations, imports, libraryExportsContents, allowedDynamicImports }
) {
  fs.readdirSync(componentFolderFullPath).forEach((filename) => {
    const filePath = path.join(componentFolderFullPath, filename);

    // if we encounter a folder, recurse!
    if (fs.lstatSync(filePath).isDirectory()) {
      recursiveFindComponents(filePath, {
        registrations,
        imports,
        libraryExportsContents,
        allowedDynamicImports,
      });
    }

    if (path.extname(filename) !== '.js') {
      return;
    }

    const fileContents = fs.readFileSync(filePath).toString();

    // Check for the existence of `import React from 'react'` within a file to
    // determine whether or not it is a component. Very rudimentary check, but
    // 60% of the time it will work every time.
    const isComponent = fileContents.search(/import.*React.*from ('|")react('|")/gim) !== -1;
    if (!isComponent) {
      // console.log(`file ${filePath} is not a component`);
      return;
    }

    const parsedFilePath = path.parse(filePath);

    // path.parse().name returns the filename without extension
    let componentName = parsedFilePath.name;
    // Some components are in `index.js` files instead of `ComponentName.js` files.
    // So in that case we use the name of the folder containing the file.
    // Not great, but that's what happens when file/folder structures are inconsistent.
    if (filename.toLowerCase() === 'index.js') {
      componentName = path.basename(path.dirname(filePath));
    }

    if (excludeComponents.indexOf(componentName) !== -1) {
      console.info(`Excluding component ${componentName}`);
      return;
    }

    const isDynamicImport = () => {
      return allowedDynamicImports.indexOf(componentName) !== -1;
    };

    // Function for handling dynamic imports
    const handleDynamicImport = () => {
      console.info(`Registering dynamic component ${componentName}`);
      // note: for dynamic components, we don't need to add to the `import` statement of the other components.
      // Dynamic components are "imported" inline.

      // Get the folder path relative to `ui-components/dist`.
      const componentFolder = componentFolderFullPath.replace(
        componentLibraryModuleResolvedBasePath,
        componentLibraryModuleBasePath
      );

      // construct the dynamic component import path, e.g. @altola-jss-components/components/MyComponentFolder/MyComponent
      // note: need to replace `\` with `/`
      const dynamicImportPath = replaceAll(
        path.join(componentFolder, ""),
        path.win32.sep,
        path.posix.sep
      );
      registrations.push(`
// NOTE: 'import' paths _must_ be static in order for webpack to be able to analyze them at build time.
components.set('${componentName}', loadable(() => import(/* webpackChunkName: "${componentName}" */'${dynamicImportPath}')))`);
    };

    const isStandardImport = () => {
      return libraryExportsContents.indexOf(`as ${componentName}`) !== -1;
    };

    // Function for handling standard imports
    const handleStandardImport = () => {
      console.info(`Registering component ${componentName}`);
      imports.push(componentName);
      registrations.push(`components.set('${componentName}', ${componentName});`);
    };

    if (isDynamicImport()) {
      handleDynamicImport();
    } else if (isStandardImport()) {
      handleStandardImport();
    } else {
      // console.info(`component '${filePath}' is not eligible to be used in the component factory.`);
    }
  });
}

function replaceAll(str, find, replace) {
  function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1');
  }
  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
}
